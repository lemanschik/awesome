'use strict';

const dgram = require('dgram');
const Emitter = require('events');
const { Duplex } = require('readable-stream');
const debug = require('utils/debug')('dtls:server');
const CookieManager = require('lib/cookie-manager');
const { decode, encode } = require('binary-data');
const {
  contentType,
  handshakeType,
  protocolVersion,
} = require('lib/constants');
const {
  DTLSPlaintext,
  Handshake,
  ClientHello,
  HelloVerifyRequest,
} = require('lib/protocol');

const _session = Symbol('_session');
const _socket = Symbol('_socket');
const _storage = Symbol('storage');

const COOKIE_VALID_VERIFIED = 1;
const COOKIE_VALID_UNVERIFIED = 0;
const COOKIE_INVALID = -1;

/**
 * @typedef {Object} DTLSServerOptions
 * @property {dgram.Socket} [socket] dgram socket
 * @property {string} [type] dgram type socket
 * @property {CookieManager} [cookie] shared cookie
 * @property {Buffer} [options.certificate] Server certificate
 * @property {Buffer} [options.certificatePrivateKey] Private key of the server certificate
 * @property {number[]} [options.cipherSuites] List of supported cipher suites
 */

/**
 * @typedef {DTLSServerOptions} DTLSSingleServerOptions
 * @property {string} [address] Host address to listening on, see defaults in dgram.Socket.bind.
 * @property {number} port Port to listening on.
 * @property {string} remoteAddress Wait for data from this remote address.
 * @property {number} remotePort Wait for data from this remote port.
 */

/**
 * Create a handler for incoming data.
 * @param {dgram.Socket} socket UDP socket used as transport.
 * @param {Map<string, any>} storage Storage of connection mapped to ip+port.
 * @param {CookieManager} cookie Cookie manager instance.
 * @returns {Function}
 */
const createIncomingDataHandler = (socket, storage, cookie) => (
  message,
  rinfo
) => {
  debug('got a new packet from %s:%s', rinfo.address, rinfo.port);

  const peer = `${rinfo.address}:${rinfo.port}`;

  if (storage.has(peer)) {
    // handle packet in session
  } else {
    const status = isCookieValid(cookie, message);

    if (status === COOKIE_VALID_UNVERIFIED) {
      const response = createHelloVerifyRequest(cookie);
      socket.send(response, rinfo.port, rinfo.address);
    } else if (status === COOKIE_VALID_VERIFIED) {
      debug('start new connection');
    }
  }
};

/**
 * DTLS server.
 */
class Server extends Emitter {
  /**
   * @class Server
   * @param {DTLSServerOptions} options
   */
  constructor(options = {}) {
    super();

    const { socket, cookie } = options;
    const sessionStorage = new Map();

    this[_socket] = socket;
    this[_storage] = sessionStorage;

    socket.on(
      'message',
      createIncomingDataHandler(socket, sessionStorage, cookie)
    );
  }
}

/**
 * DTLS server, configured once only for specified client.
 */
class SingleServer extends Duplex {
  /**
   * @class SingleServer
   * @param {DTLSSingleServerOptions} options
   */
  constructor(options = {}) {
    super({ objectMode: false, decodeStrings: false });

    const { socket, cookie, remoteAddress, remotePort } = options;

    this[_session] = null;
    this[_socket] = socket;

    socket.on('message', (message, rinfo) => {
      debug('got a new packet from %s:%s', rinfo.address, rinfo.port);

      if (rinfo.address !== remoteAddress && rinfo.port !== remotePort) {
        debug('invalid sender');
        return;
      }

      if (this[_session] === null) {
        const status = isCookieValid(cookie, message);

        if (status === COOKIE_VALID_UNVERIFIED) {
          const response = createHelloVerifyRequest(cookie);
          socket.send(response, rinfo.port, rinfo.address);
        } else if (status === COOKIE_VALID_VERIFIED) {
          debug('start new connection');
          cookie.destroy();
        }
      } else {
        debug('handle session');
      }
    });
  }
}

/**
 * Handle client's ClientHello message by checking cookie.
 * @param {CookieManager} cookie
 * @param {Buffer} message
 * @returns {number}
 */
function isCookieValid(cookie, message) {
  debug('process ClientHello');
  const record = decode(message, DTLSPlaintext);

  if (record.type !== contentType.HANDSHAKE) {
    debug('not a handshake - %s, ignore', record.type);
    return COOKIE_INVALID;
  }

  const handshake = decode(record.fragment, Handshake);

  if (handshake.type !== handshakeType.CLIENT_HELLO) {
    debug('not a ClientHello - %s, ignore', handshake.type);
    return COOKIE_INVALID;
  }

  // Ignore fragmented (first) ClientHello due to potencial DoS.
  if (handshake.length !== handshake.fragment.length) {
    debug('got fragmented ClientHello, ignore');
    return COOKIE_INVALID;
  }

  const clientHello = decode(handshake.body, ClientHello);

  // Send HelloVerifyRequest
  if (clientHello.cookie.length === 0) {
    return COOKIE_VALID_UNVERIFIED;
  }

  if (cookie.validate(clientHello.cookie)) {
    debug('cookie is valid');
    return COOKIE_VALID_VERIFIED;
  }

  debug('invalid cookie, ignore');
  return COOKIE_INVALID;
}

/**
 * Send HelloVerifyRequest message.
 * @param {CookieManager} cookie
 * @returns {Buffer}
 */
function createHelloVerifyRequest(cookie) {
  const helloVerifyRequest = {
    serverVersion: protocolVersion.DTLS_1_2,
    cookie: cookie.current,
  };

  const handshakePayload = encode(
    helloVerifyRequest,
    HelloVerifyRequest
  ).slice();

  const handshake = {
    type: handshakeType.HELLO_VERIFY_REQUEST,
    length: handshakePayload.length,
    sequence: 0,
    fragment: {
      offset: 0,
      length: handshakePayload.length,
    },
    body: handshakePayload,
  };

  const headerPayload = encode(handshake, Handshake).slice();

  const record = {
    type: contentType.HANDSHAKE,
    version: protocolVersion.DTLS_1_2,
    epoch: 0,
    sequenceNumber: 0,
    length: headerPayload.length,
    fragment: headerPayload,
  };

  return encode(record, DTLSPlaintext).slice();
}

/**
 * Create DTLS server.
 * @param {DTLSServerOptions} options
 * @param {Function} callback
 * @returns {Server}
 */
function createServer(options, callback) {
  if (!options.socket) {
    options.socket = dgram.createSocket(options);
  }

  if (!options.cookie) {
    options.cookie = new CookieManager();
  }

  const server = new Server(options);

  if (typeof callback === 'function') {
    server.once('connect', callback);
  }

  return server;
}

module.exports = {
  createServer,
  Server,
  SingleServer,
};
