'use strict';

const assert = require('assert');
const Emitter = require('events');
const debug = require('utils/debug')('dtls:retransmitter');
const { createMachine, createState } = require('next-state');

const PREPARING = 'preparing';
const SENDING = 'sending';
const WAITING = 'waiting';
const FINISHED = 'finished';

const _timer = Symbol('timer');
const _ms = Symbol('ms');
const _queue = Symbol('queue');
const _onTimeout = Symbol('onTimeout');
const _tries = Symbol('tries');
const _machine = Symbol('machine');

/**
 * Allowed state transitions.
 * @see https://tools.ietf.org/html/rfc6347#section-4.2.4
 */
const transitions = {
  [PREPARING]: createState(SENDING),
  [SENDING]: createState(WAITING, FINISHED),
  [WAITING]: createState(PREPARING, SENDING, FINISHED),
  [FINISHED]: createState(PREPARING),
};

const INIT_TIMEOUT = 1e3; // Initial timer is 1s

/**
 * Timeout handler.
 * @param {Timer} self
 */
function ontimeout(self) {
  self.emit('timeout');
}

/**
 * This class implements convenient timers.
 */
class Timer extends Emitter {
  /**
   * @class Timer
   */
  constructor() {
    super();

    this[_onTimeout] = null;
  }

  /**
   * Stop active timeout.
   */
  stop() {
    if (this[_onTimeout] !== null) {
      clearTimeout(this[_onTimeout]);
      this[_onTimeout] = null;
    }
  }

  /**
   * Restart current timeout.
   * @param {number} ms
   */
  restart(ms) {
    this.stop();

    this[_onTimeout] = setTimeout(ontimeout, ms, this).unref();
  }
}

/**
 * Timeout and Retransmission State Machine.
 */
class RetransmitMachine extends Emitter {
  /**
   * @class RetransmitMachine
   * @param {string} initialState
   */
  constructor(initialState) {
    super();

    const timer = new Timer();
    const machine = createMachine(transitions, initialState);
    const queue = [];

    this[_timer] = timer;
    this[_ms] = INIT_TIMEOUT;
    this[_tries] = 0;
    this[_machine] = machine;
    this[_queue] = queue;

    // Implementations SHOULD use an initial timer value
    // of 1 second and double the value at each retransmission,
    // up to no less than the RFC 6298 maximum of 60 seconds.
    this.maxTries = Math.log2(64) + 1;

    timer.on('timeout', () => {
      this[_tries] += 1;

      if (this[_tries] > this.maxTries) {
        debug('got timeout, max tries (%s) is reached, close', this.maxTries);
        this.close();
        return;
      }

      /**
       * Double the value at each retransmission
       * @see https://tools.ietf.org/html/rfc6347#section-4.2.4.1
       */
      this[_ms] = Math.min(this[_ms] * 2, 60e3);

      debug('got timeout, next time is %s ms', this[_ms]);
      this.emit('timeout');
    });

    this.on('timeout', () => {
      if (queue.length === 0) {
        debug('empty queue, ignore');
        return;
      }

      if (this.state !== WAITING) {
        return;
      }

      debug('send stored messages again');
      queue.forEach(item => this.emit('data', item));
      this.send();
    });

    [PREPARING, SENDING, WAITING, FINISHED].forEach(event =>
      machine.on(event, () => this.emit(event))
    );
  }

  /**
   * Get the current state of the State Machine.
   */
  get state() {
    return this[_machine].state;
  }

  /**
   * @returns {Timer}
   */
  get timer() {
    return this[_timer];
  }

  /**
   * Change state to `FINISHED`.
   */
  finish() {
    this.timer.stop();
    this[_queue].length = 0;
    this[_machine].next(FINISHED);
  }

  /**
   * Change state to `WAITING`.
   */
  wait() {
    const ms = this[_ms];

    this.timer.restart(ms);
    this[_machine].next(WAITING);
  }

  /**
   * Change state to `SENDING`.
   */
  send() {
    this[_machine].next(SENDING);
  }

  /**
   * Change state to `PREPARING`.
   */
  prepare() {
    this.timer.stop();
    this[_queue].length = 0;

    // After every success data transfer reset timer to
    // it's initial value.
    this[_ms] = INIT_TIMEOUT;
    this[_machine].next(PREPARING);
  }

  /**
   * Create a new flight and buffer it.
   * @param {number} type
   * @param {number} epoch
   * @param {Buffer} packet Handshake messages.
   */
  append(type, epoch, packet) {
    assert(this.state === PREPARING);
    debug('save packet');

    this[_queue].push({ type, epoch, packet });
  }

  /**
   * Close the State Machine.
   */
  close() {
    this.timer.stop();
    this.emit('close');
  }
}

/**
 * Create Timeout and Retransmission State Machine
 * for the clients.
 * @returns {RetransmitMachine}
 */
function createRetransmitClient() {
  return new RetransmitMachine(PREPARING);
}

/**
 * Create Timeout and Retransmission State Machine
 * for the servers.
 * @returns {RetransmitMachine}
 */
function createRetransmitServer() {
  return new RetransmitMachine(WAITING);
}

module.exports = {
  createRetransmitClient,
  createRetransmitServer,
  RetransmitMachine,
  states: {
    PREPARING,
    SENDING,
    WAITING,
    FINISHED,
  },
};
