'use strict';

const Events = require('events');
const crypto = require('crypto');
const ms = require('ms');
const timeout = require('timeout-refresh');
const debug = require('utils/debug')('dtls:cookie');

const _renewTimer = Symbol('renewTimer');
const _expireTimer = Symbol('expireTimer');
const _cookie = Symbol('cookie');
const _cookieSize = Symbol('cookieSize');
const _prevCookie = Symbol('prevCookie');

const defaultOptions = {
  renew: ms('30m'),
  expire: ms('30s'),
  size: 10,
};

/**
 * @typedef {Object} CookieManagerOptions
 * @property {number} renew Time to update cookie
 * @property {number} expire Time to expire previous cookie
 * @property {number} size Cookie size
 */

/**
 * This class manage server cookies.
 */
module.exports = class CookieManager extends Events {
  /**
   * @class CookieManager
   * @param {CookieManagerOptions} options
   */
  constructor(options = defaultOptions) {
    super();

    if (options !== defaultOptions) {
      options = Object.assign({}, defaultOptions, options); // eslint-disable-line no-param-reassign
    }

    debug('start cookie manager');

    // this[_timeout] = timeout;
    this[_prevCookie] = null;
    this[_cookieSize] = options.size;

    // Sync for first time.
    this[_cookie] = crypto.randomBytes(options.size);

    const expireTimer = timeout(options.expire, () => {
      this[_prevCookie] = null;
      debug('drop previous cookie');
    });

    const renewTimer = timeout(options.renew, () => {
      crypto.randomBytes(options.size, (err, cookie) => {
        if (!err) {
          this[_prevCookie] = this[_cookie];
          this[_cookie] = cookie;

          debug('cookie was updated');
          this.emit('renew', cookie);
        } else {
          debug('got error', err);
          this.emit('error', err);
        }

        expireTimer.refresh();
        renewTimer.refresh();
      });
    });

    this[_renewTimer] = renewTimer;
    this[_expireTimer] = expireTimer;
  }

  /**
   * Validate the cookie.
   * @param {Buffer} cookie Recived cookie.
   * @returns {boolean}
   */
  validate(cookie) {
    if (!Buffer.isBuffer(cookie)) {
      throw new TypeError('Expected a Buffer');
    }

    if (Buffer.compare(cookie, this.current) === 0) {
      return true;
    }

    if (
      Buffer.isBuffer(this.previous) &&
      Buffer.compare(cookie, this.previous) === 0
    ) {
      return true;
    }

    return false;
  }

  /**
   * Get current cookie.
   * @returns {Buffer}
   */
  get current() {
    return this[_cookie];
  }

  /**
   * Get previous cookie until it's fully expired.
   * @returns {Buffer} Get `null` if expired.
   */
  get previous() {
    return this[_prevCookie];
  }

  /**
   * Destroy cookie manager.
   */
  destroy() {
    this[_renewTimer].destroy();
    this[_expireTimer].destroy();
  }
};
