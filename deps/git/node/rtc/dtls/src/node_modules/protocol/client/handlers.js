'use strict';

/**
 * This file contains a collection of DTLS protocol handlers for client side.
 * It hides many session-based stuffs.
 */

const assert = require('assert');
const crypto = require('crypto');
const debug = require('utils/debug')('dtls:client-protocol');
const { constants: states } = require('protocol/packet');
const { createCipher } = require('cipher/create');
const { decode, createDecode } = require('binary-data');
const x509 = require('@fidm/x509');
const { ASN1 } = require('@fidm/asn1');
const {
  HelloVerifyRequest,
  ServerHello,
  Certificate,
  Alert,
  ALPNProtocolNameList,
  ExtensionList,
  ServerECDHParams,
  DigitallySigned,
  CertificateRequest,
  ServerPSKIdentityHint,
} = require('lib/protocol');
const {
  alertDescription,
  maxSessionIdSize,
  extensionTypes,
  keyTypes,
  signTypes,
  namedCurves,
  signatureScheme,
  kxTypes,
} = require('lib/constants');
const {
  getHashNameBySignAlgo,
  getCertificateType,
  getCertificateSignatureAlgorithm,
} = require('session/utils');

const {
  CLIENT_HELLO,
  CERTIFICATE,
  CERTIFICATE_VERIFY,
  CLIENT_KEY_EXCHANGE,
  FINISHED,
  CHANGE_CIPHER_SPEC,
} = states;

const supportedCurves = Object.keys(namedCurves);

module.exports = {
  clientHello,
  helloVerifyRequest,
  serverHello,
  serverHelloExtensions,
  serverCertificate,
  serverKeyExchange,
  certificateRequest,
  serverHelloDone,
  clientCertificate,
  clientKeyExchange,
  certificateVerify,
  clientChangeCipherSpec,
  clientFinished,
  serverChangeCipherSpec,
  serverFinished,
  alert,
  applicationData,
};

/**
 * Handles `client hello` out message.
 * @param {ClientSession} session
 */
function clientHello(session) {
  debug('prepare client hello');
  session.send(CLIENT_HELLO);
  session.retransmitter.send();
}

/**
 * Handles `hello verify request` incoming message.
 * @param {ClientSession} session
 * @param {Object} message
 */
function helloVerifyRequest(session, message) {
  debug('got hello verify request');
  session.retransmitter.prepare();

  const handshake = message.fragment;

  // Initial `ClientHello` and `HelloVerifyRequest` must not
  // use for calculate finished checksum.
  session.resetHandshakeQueue();

  const packet = decode(handshake.body, HelloVerifyRequest);
  assert(decode.bytes === handshake.body.length);

  session.cookie = packet.cookie;
  debug('got cookie %h', packet.cookie);
}

/**
 * Handles `server hello` incoming message.
 * @param {ClientSession} session
 * @param {Object} message
 */
function serverHello(session, message) {
  debug('got server hello');
  const handshake = message.fragment;

  if (handshake.body.length < 38) {
    session.error(alertDescription.DECODE_ERROR);
    return;
  }

  const istream = createDecode(handshake.body);
  const serverHelloPacket = decode(istream, ServerHello);

  if (serverHelloPacket.serverVersion !== session.version) {
    debug('mismatch protocol version');
    session.error(alertDescription.PROTOCOL_VERSION);
    return;
  }

  if (serverHelloPacket.sessionId.length > maxSessionIdSize) {
    session.error(alertDescription.ILLEGAL_PARAMETER);
    return;
  }

  session.serverRandom = serverHelloPacket.random;
  session.id = serverHelloPacket.sessionId;

  const clientCipher = session.cipherSuites.find(
    cipherSuite => cipherSuite === serverHelloPacket.cipherSuite
  );

  if (!clientCipher) {
    debug('server selected unknown cipher %s', serverHelloPacket.cipherSuite);
    session.error(alertDescription.HANDSHAKE_FAILURE);
    return;
  }

  const cipher = createCipher(clientCipher);

  debug(`server selected ${cipher.name} cipher`);
  session.nextCipher = cipher;

  if (istream.length > 0) {
    const extensions = decode(istream, ExtensionList);

    serverHelloExtensions(session, extensions);
  }

  const { extendedMasterSecret, peerExtendedMasterSecret } = session;

  // If a client receives a ServerHello without the extension, it SHOULD
  // abort the handshake if it does not wish to interoperate with legacy
  // servers.
  if (extendedMasterSecret && !peerExtendedMasterSecret) {
    session.error(alertDescription.HANDSHAKE_FAILURE);
    return;
  }

  // Ignore server's choise of Supported Point Formats Extension.
  // Force use of uncompressed points.

  session.appendHandshake(handshake);
}

/**
 * Handle `server hello` extensions.
 * @param {ClientSession} session
 * @param {Object[]} extensions
 */
function serverHelloExtensions(session, extensions) {
  for (const extension of extensions) {
    if (extension.type === extensionTypes.EXTENDED_MASTER_SECRET) {
      session.peerExtendedMasterSecret = true;
    }

    if (
      extension.type === extensionTypes.APPLICATION_LAYER_PROTOCOL_NEGOTIATION
    ) {
      const protocols = decode(extension.data, ALPNProtocolNameList);

      if (protocols.length === 1) {
        const [alpn] = protocols;

        session.selectedALPNProtocol = alpn;
      }
    }
  }
}

/**
 * Handles `certificate` incoming message.
 * @param {ClientSession} session
 * @param {Object} message
 */
function serverCertificate(session, message) {
  debug('got server certificate');
  const handshake = message.fragment;

  // PSK key exchange don't need this message.
  if (session.nextCipher.kx.id === kxTypes.PSK) {
    throw new Error('Invalid message.');
  }

  const packet = decode(handshake.body, Certificate);

  if (packet.certificateList.length === 0) {
    session.error(alertDescription.CERTIFICATE_UNKNOWN);
    return;
  }

  // The sender's certificate MUST come first in the list.
  const serverCertificatePacket = packet.certificateList[0];
  const certificate = new x509.Certificate(
    ASN1.fromDER(serverCertificatePacket)
  );

  const isValid = session.verifyCertificate(certificate);

  if (!isValid) {
    session.error(alertDescription.BAD_CERTIFICATE);
    return;
  }

  session.certificate(certificate);
  session.serverPublicKey = certificate.publicKey.toPEM();

  session.appendHandshake(handshake);
}

/**
 * Handle `ServerKeyExchange` message.
 * @param {ClientSession} session
 * @param {Object} message
 */
function serverKeyExchange(session, message) {
  debug('got server key exchange');
  const { nextCipher } = session;

  const isECDHE = nextCipher.kx.signType === signTypes.ECDHE;
  const isPSK = nextCipher.kx.id === kxTypes.PSK;
  const isECDHE_PSK = nextCipher.kx.id === kxTypes.ECDHE_PSK; // eslint-disable-line camelcase

  // Only ECDHE_* and PSK may have this message.
  // eslint-disable-next-line camelcase
  if (isECDHE_PSK) {
    serverECDHEPSKKeyExchange(session, message);
  } else if (isECDHE) {
    serverECDHEKeyExchange(session, message);
  } else if (isPSK) {
    serverPSKKeyExchange(session, message);
  } else {
    throw new Error('Invalid message type.');
  }
}

/**
 * Process `ServerKeyExchange` message for ECDHE_* key exchange (except ECDHE_PSK).
 * @param {ClientSession} session
 * @param {Object} message
 */
function serverECDHEKeyExchange(session, message) {
  debug('process server ECDHE key exchange');

  const handshake = message.fragment;
  const rstream = createDecode(handshake.body);

  const ecdheParams = decode(rstream, ServerECDHParams);
  const ecdheParamsSize = decode.bytes;
  const digitalSign = decode(rstream, DigitallySigned);

  // check curve
  const selectedCurve = supportedCurves.find(
    curve => namedCurves[curve] === ecdheParams.curve
  );

  if (selectedCurve === undefined) {
    throw new Error('Invalid curve name');
  }

  // Default sign algo is sha1 for rsa
  if (session.nextCipher.kx.keyType === keyTypes.RSA) {
    assert(digitalSign.algorithm === signatureScheme.rsa_pkcs1_sha1);
  }

  if (session.nextCipher.kx.keyType === keyTypes.ECDSA) {
    const isECDSA =
      digitalSign.algorithm === signatureScheme.ecdsa_sha1 ||
      digitalSign.algorithm === signatureScheme.ecdsa_secp256r1_sha256 ||
      digitalSign.algorithm === signatureScheme.ecdsa_secp384r1_sha384 ||
      digitalSign.algorithm === signatureScheme.ecdsa_secp521r1_sha512;
    assert(isECDSA);
  }

  const verifier = crypto.createVerify(
    getHashNameBySignAlgo(digitalSign.algorithm)
  );

  verifier.update(session.clientRandom);
  verifier.update(session.serverRandom);
  verifier.update(handshake.body.slice(0, ecdheParamsSize));

  const isSignValid = verifier.verify(
    { key: session.serverPublicKey },
    digitalSign.signature
  );

  if (!isSignValid) {
    throw new Error('Invalid sign');
  }

  debug('sign valid');

  session.appendHandshake(handshake);
  session.ellipticCurve = selectedCurve;
  session.peerEllipticPublicKey = ecdheParams.pubkey;
  session.createElliptic();
}

/**
 * Process `ServerKeyExchange` message for PSK key exchange.
 * @param {ClientSession} session
 * @param {Object} message
 */
function serverPSKKeyExchange(session, message) {
  debug('process server PSK key exchange');

  const handshake = message.fragment;
  const rstream = createDecode(handshake.body);

  /**
   * In the absence of an application profile specification specifying
   * otherwise, servers SHOULD NOT provide an identity hint and clients
   * MUST ignore the identity hint field.
   */

  if (!session.ignorePSKIdentityHint) {
    const pskIdentityHint = decode(rstream, ServerPSKIdentityHint);

    session.serverPSKIdentityHint = pskIdentityHint;
  }

  session.appendHandshake(handshake);
}

/**
 * Process `ServerKeyExchange` message for ECDHE_PSK key exchange.
 * @param {ClientSession} session
 * @param {Object} message
 */
function serverECDHEPSKKeyExchange(session, message) {
  debug('process server ECDHE PSK key exchange');

  const handshake = message.fragment;
  const rstream = createDecode(handshake.body);

  const pskIdentityHint = decode(rstream, ServerPSKIdentityHint);
  const ecdheParams = decode(rstream, ServerECDHParams);

  if (!session.ignorePSKIdentityHint) {
    session.serverPSKIdentityHint = pskIdentityHint;
  }

  // check curve
  const selectedCurve = supportedCurves.find(
    curve => namedCurves[curve] === ecdheParams.curve
  );

  if (selectedCurve === undefined) {
    throw new Error('Invalid curve name');
  }

  session.appendHandshake(handshake);
  session.ellipticCurve = selectedCurve;
  session.peerEllipticPublicKey = ecdheParams.pubkey;
  session.createElliptic();
}

/**
 * Handles `certificate request` incoming message.
 * @param {ClientSession} session
 * @param {Object} message
 */
function certificateRequest(session, message) {
  debug('got certificate request');
  const handshake = message.fragment;
  const { nextCipher } = session;

  // PSK key exchange don't need this message.
  if (nextCipher.kx.keyType === keyTypes.PSK) {
    throw new Error('Invalid message.');
  }

  const { certificateTypes, signatures } = decode(
    handshake.body,
    CertificateRequest
  );

  session.isCertificateRequested = true;
  session.requestedCertificateTypes = certificateTypes;
  session.requestedSignatureAlgorithms = signatures;

  session.appendHandshake(handshake);
}

/**
 * Handles `server hello done` incoming message.
 * @param {ClientSession} session
 * @param {Object} message
 * @param {Function} cb
 */
function serverHelloDone(session, message, cb) {
  debug('got server hello done');
  const handshake = message.fragment;

  session.appendHandshake(handshake);
  session.createPreMasterSecret(() => {
    debug('PREMASTER SECRET %h', session.clientPremaster);
    cb();
  });
}

/**
 * Sends client side certificate.
 * @param {ClientSession} session
 */
function clientCertificate(session) {
  debug('prepare client certificate');

  session.retransmitter.prepare();

  if (session.clientCertificate !== null) {
    // The end-entity certificate provided by the client MUST contain a
    // key that is compatible with certificate_types.
    const certType = getCertificateType(session.clientCertificate);
    const isCertificateAllowed = session.requestedCertificateTypes.includes(
      certType
    );

    if (!isCertificateAllowed) {
      throw new Error('Disallowed certificate type.');
    }

    // Any certificates provided by the client MUST be signed using a
    // hash/signature algorithm pair found in
    // supported_signature_algorithms.
    const signalgo = getCertificateSignatureAlgorithm(
      session.clientCertificate
    );
    const isCertificatSignatureAllowed = session.requestedSignatureAlgorithms.includes(
      signalgo
    );

    if (!isCertificatSignatureAllowed) {
      throw new Error('Disallowed certificate signature algorithm.');
    }

    session.clientCertificateSignatureAlgorithm = signalgo;
  }

  session.send(CERTIFICATE);
}

/**
 * Sends `client key exchange` message.
 * @param {ClientSession} session
 */
function clientKeyExchange(session) {
  debug('prepare client key exchange');
  const { isCertificateRequested } = session;

  if (!isCertificateRequested) {
    session.retransmitter.prepare();
  }

  session.send(CLIENT_KEY_EXCHANGE);

  session.createMasterSecret();
  debug('MASTER SECRET %h', session.masterSecret);

  session.needCertificateVerify =
    isCertificateRequested && session.clientCertificate !== null;
}

/**
 * Send CERTIFICATE_VERIFY message.
 * @param {ClientSession} session
 */
function certificateVerify(session) {
  debug('prepare certificate verify');

  session.createSignature();
  session.send(CERTIFICATE_VERIFY);
}

/**
 * Send CHANGE_CIPHER_SPEC message.
 * @param {ClientSession} session
 */
function clientChangeCipherSpec(session) {
  debug('prepare change cipher spec');

  session.send(CHANGE_CIPHER_SPEC);
  session.nextEpochClient();
}

/**
 * Send FINISHED message.
 * @param {ClientSession} session
 */
function clientFinished(session) {
  debug('prepare client finished');
  session.createClientFinished();
  debug('client finished %h', session.clientFinished);

  session.send(FINISHED);
  session.retransmitter.send();
}

/**
 * Send CHANGE_CIPHER_SPEC message.
 * @param {ClientSession} session
 */
function serverChangeCipherSpec(session) {
  debug('got change cipher spec');
  session.nextEpochServer();
}

/**
 * Handle FINISHED message.
 * @param {ClientSession} session
 * @param {Object} message
 */
function serverFinished(session, message) {
  debug('got finished');

  const handshake = message.fragment;
  debug('received server finished %h', handshake.body);

  session.createServerFinished();
  debug('computed server finished %h', session.serverFinished);

  if (Buffer.compare(handshake.body, session.serverFinished) !== 0) {
    throw new Error('Mismatch server finished messages');
  }

  session.retransmitter.finish();
  session.finishHandshake();
}

/**
 * Handle incoming `alert` messages.
 * @param {ClientSession} session
 * @param {Object} message
 */
function alert(session, message) {
  debug('got alert');
  const packet = message.fragment;

  const { level, description } = decode(packet, Alert);
  debug('level %s, description %s', level, description);

  session.error(description);
}

/**
 * Handle incoming `application data` message.
 * @param {ClientSession} session
 * @param {Object} message
 */
function applicationData(session, message) {
  debug('got application data');

  const appdata = message.fragment;
  debug('packet: %h', appdata);

  session.packet(appdata);
}
